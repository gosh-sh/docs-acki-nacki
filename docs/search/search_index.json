{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Secured! Decentralized! Fast!","text":"<p>Acki Nacki is based on consensus research paper</p> <p>Acki Nacki is asynchronous, highly effective proof-of-stake protocol optimized for fast finality, while allowing for high throughputs via execution parallelization. It is a probabilistic protocol that achieves higher Byzantine fault tolerance than Nakamoto, BFT (including Hotstuff and AptosBFT), Solana, and other modern consensus protocols. Our protocol reaches consensus in two communication steps and has a total number of messages that are subquadratic to the number of nodes, with probabilistic, dynamically adjusted safety guarantees. We trade off deterministic consensus with theoretical constraints on message complexity and the number of Byzantine agreements, with probabilistic algorithms overtaking these boundaries. We further claim that because of the use of randomness and socioeconomics in blockchain designs, no real trade-off is actually present. One of the key ingredients of our approach is separating the verification of execution by a consensus committee from the attestation of block propagation by network participants. Our consensus committee is randomly selected for each block and is not predetermined, while the Leader is deterministic.</p> <p></p>"},{"location":"#watch-the-event-here","title":"watch the event here","text":""},{"location":"links/","title":"Links","text":"<p>Acki Nacki Website</p> <p>Acki Nacki Telegram Group</p> <p>Acki Nicki Telegram Channel</p> <p>Acki Nacki Youtube</p> <p>Acki Nacki TikTok</p> <p>Acki Nacki Instagram</p> <p>Acki Nacki Twitter</p> <p>Acki Nacki Blockchain Explorer</p>"},{"location":"acki-nacki/info/","title":"About network","text":"<p>In all Quick Starts, the contract <code>helloWorld.sol</code> will be used as an example. Its creation is described here.</p> <p>We recommend creating a wallet-contract that will serve as your giver.</p> <p>To replenish it, please contact us in Channel on Telegram.</p>"},{"location":"acki-nacki/overview/","title":"About protocol","text":""},{"location":"acki-nacki/overview/#introduction","title":"Introduction","text":"<p>Current public blockchains are almost exclusively used for financial applications, be it for the store and transfer of value or decentralized finance. Users are ready to pay gas and transaction fees when transacting in value. The primary reason for this user experience inefficiency is the inherent lack of performance in both transaction execution throughput and time to finality, due to strict requirements on state validation. </p> <p>We present a highly efficient, scalable, and practical blockchain protocol optimized for heavy parallelization and extremely fast finality times. The goal of the protocol is to produce performance comparable to cluster cloud databases without compromising security.</p>"},{"location":"acki-nacki/overview/#background","title":"Background","text":"<p>Consensus protocols in computer science are categorized into probabilistic and deterministic. Since 1978, deterministic protocols have evolved, leading to pBFT's creation for varied applications without addressing decentralized money's double spending challenge.</p>"},{"location":"acki-nacki/overview/#bitcoin","title":"Bitcoin","text":"<p>Nakamoto's Bitcoin, introduced on October 31, 2008, first solved double spending with a Proof-of-Work (PoW) probabilistic consensus. Miners compete by solving cryptographic puzzles for block proposal rights, embedding economic incentives into its security. Despite its pioneering role, Bitcoin's low transaction rate (7 transactions per second) and long finalization times limit its functionality beyond a store and transfer of value.</p>"},{"location":"acki-nacki/overview/#bft","title":"BFT","text":"<p>Before Ethereum in 2014, S. King and S. Nadal proposed Proof-of-Stake (PoS) in 2012, enabling deterministic protocols like pBFT in cryptocurrencies by staking assets. This shift allowed enhancements over pBFT, but BFT's deterministic nature is diluted in PoS due to economic variables and probabilistic encryption, aligning its security more with cryptography and game theory despite performance sacrifices.</p>"},{"location":"acki-nacki/overview/#fast-byzantine-paxos","title":"Fast Byzantine Paxos","text":"<p>This protocol, aiming for rapid asynchronous consensus, requires consensus in two steps normally but necessitates &gt;= 5 * f + 1 nodes to manage f Byzantine nodes, a stricter requirement than pBFT. It illustrates the deterministic protocols' limitations in efficiently addressing malicious nodes.</p>"},{"location":"acki-nacki/overview/#modern-blockchains","title":"Modern Blockchains","text":"<p>Recognizing performance problems of Nakamoto and BFT consensus protocols lately few other approaches  surfaced. We will compare with three most performant of them: Solana, Avalanche, Aptos, Algorand and Dfinity.</p>"},{"location":"acki-nacki/overview/#solana","title":"Solana","text":"<p>Solana stands out as a blockchain platform designed for decentralized applications (dApps), focusing on high scalability and efficiency. It boasts a superior transaction processing capability, enabling higher transactions per second (TPS) with lower fees. Solana combines Proof of Stake (PoS) with Proof of History (PoH), a concept introduced by Yakovenko, to verify time passage between events, enhancing consensus efficiency. This approach uses validator clusters instead of individual nodes, though its scientific basis has faced scrutiny.</p>"},{"location":"acki-nacki/overview/#avalanche","title":"Avalanche","text":"<p>The Avalanche consensus mechanism involves nodes conducting repeated voting among a small group of validator nodes to determine transaction acceptance. Validators respond with their preferred transaction, and if a significant majority agrees, that transaction is chosen. Parameters like the threshold for agreement and Confidence Threshold are adjustable. Avalanche subsampling has low message overhead regardless of the number of validators. Transitive voting helps with transaction throughput. Delays can occur when multiple blocks are proposed simultaneously. The attack probability in Avalanche dynamically changes based on input parameters, affecting finalization time and message complexity.</p>"},{"location":"acki-nacki/overview/#aptosbft","title":"AptosBFT","text":"<p>The Aptos builds on advanced pBFT variants like Hotstuff, focusing on random leader selection for each block to improve consensus. However, this necessitates frequent message replication across all network nodes, adding quadratic complexity and impacting overall performance.</p>"},{"location":"acki-nacki/overview/#algorand","title":"Algorand","text":"<p>The Algorand is a strongly synchronous 3-step protocol. Algorand relies on a public randomness computed in previous blocks. It is used to elect a committee of leaders and a committee of block validators at each round that will have a sufficient number of honest nodes with overwhelming probability. The Algorand\u2019s communication steps consist of: gossip propagation of blocks from all network leaders, BFT among the committee of validators, and the final gossip propagation of the block to the network. The Algorand requires more than 2/3 of the nodes in the validator committee to be honest to ensure security guarantees during the execution of the BFT protocol.</p>"},{"location":"acki-nacki/overview/#dfinity","title":"Dfinity","text":"<p>The Dfinity consensus protocol has four layers: client identities, decentralized random beacon, blockchain with leader ranking, and decentralized notary for finality. Security assumption requires a certain ratio of honest to malicious nodes. The consensus process involves 4 steps with different latencies based on adversary types. In the original paper, the message complexity is unbounded. However, the proposed modification reduces  the expected communication complexities against an adaptive adversary, and against a static or mildly adaptive adversary</p>"},{"location":"acki-nacki/overview/#sharding","title":"Sharding","text":"<p>The Sharding a method aimed at boosting performance through data and execution partitioning, was pioneered by Zilliqa and further developed in Ethereum for state sharding. Protocols like TON, Near, and Elrond also employ sharding with parallel leader selection and state synchronization to enhance throughput. Despite these advancements, sharding and parallel execution technologies have yet to surpass a practical limit of around 100K TPS in controlled tests, indicating persistent scalability challenges in blockchain consensus mechanisms.</p>"},{"location":"acki-nacki/overview/#construction-of-acki-nacki","title":"Construction of Acki Nacki","text":"<p>The Acki Nacki probabilistic consensus protocol intends to take the performance of fault-tolerant consensus protocols as far as we can. In Acki Nacki, participants can perform three roles: Block Producer, Block Keeper and Verifier (which we call the Acki-Nacki entity). All of these roles could be performed by any network participant in parallel. So many Acki Nacki chains (called Threads) can exist simultaneously, but since their security and functionality do not depend on each other</p>"},{"location":"acki-nacki/overview/#definitions","title":"Definitions","text":"<p>Account (contract) is a record in a distributed database.</p> <p>Thread is a subset of nodes that serves a particular subset of Accounts.</p> <p>Block is an object that contains new transactions which, once finalized, are stored in the blockchain as a permanent and immutable part of this decentralized ledger. Each block includes information such as transaction data, timestamp, common section, and a reference to the previous block, creating a chain of interconnected blocks.</p> <p>Common section is the section of the block that contains information that needs to be shared among all network participants. </p> <p>Block Producer (BP) is a leader of a particular Thread responsible for block production.</p> <p>Block Keeper (BK) is an entity having two functions:  Receives blocks from BP and sends out an Attestation with block hash and other metadata back to BP. BK does not check block transactions validity, it does not try to execute the block, only apply it to its local state with a mark 'Not Final'. Performs a self check if it needs to become a Verifier for this block as described below. If it does, BK will verify the Block and broadcast the result: Ack, if the Block is ok and Nack, if the block is invalid.</p> <p>Verifier (Acki-Nacki) \u2014 is a BK being responsible for block validation and notifying all network participants about his verdict: is block valid or not.</p> <p>Attestation \u2014 message that is sent to BP by any BK after receiving the block. Attestation is BLS signature done on BK\u2019s private key. BP of the next block must aggregate all received Attestations for the previous block into one BLS signature and include it into the Common section of the new block.</p> <p>Ack \u2014 Verifier\u2019s message that is broadcasted to all network participants by Acki-Nacki if the block is verified and it\u2019s valid. </p> <p>Nack \u2014 Verifier\u2019s message that is broadcasted to all network participants by Acki-Nacki if the block is verified and it\u2019s NOT valid.</p> <p>Attestations and Verifier\u2019s messages must contain block hash, its BLS signature on BK\u2019s private key. Some extra data may be added. For example, Nack contains the reason for block rejection.</p>"},{"location":"acki-nacki/overview/#security-assumptions","title":"Security Assumptions","text":"<p>We follow standard assumptions of Safety and Liveness properties for Acki Nacki protocol. These properties make the network operation look like the operation of a monolithic valid server i.e. linearizable consistent block ledger. Safety: there are no two honest BK accepting different blocks of the same height and no block with an incorrect transaction is being finalized Liveness: If an honest BP has received a transaction then it will be eventually included in every honest node\u2019s ledger.</p> <p>In accordance with these properties, we classify the attacks violating them:</p>"},{"location":"acki-nacki/overview/#safety-attacks","title":"Safety attacks","text":"<p>Such attacks include dissemblance and private chain attacks. Dissemblance means that the adversary maintains Byzantine nodes to send different messages to different nodes, which may lead to nodes\u2019 disagreement. Private chain attacks mean that the adversary controls Byzantine nodes to work on a separate blockchain privately while following the protocol. </p>"},{"location":"acki-nacki/overview/#liveness-attacks","title":"Liveness attacks","text":"<p>Liveness attacks. These types of attacks include the aforementioned dissemblance and withholding attacks. Apart from safety, dissemblance may retain honest nodes to make decisions forever, breaking the liveness. Retaining means that the adversary which controls Byzantine nodes doesn't send messages to particular nodes, which may also retain them to make decisions forever.</p>"},{"location":"acki-nacki/overview/#block-producer-selection","title":"Block Producer selection","text":"<p>In Acki-Nacki, the selection of Block Producers (BPs) is not random due to security concerns regarding potentially malicious BPs. Instead, a deterministic algorithm is used where the hash of a block with a shard split or other message serves as a seed for random sampling of one BP from a sorted list of BPs' public keys. The current list of BPs is always included in the Common Section of any Block, which also contains other block-related data such as Attestations, Verifier's messages, slashing/reward conditions, etc.</p>"},{"location":"acki-nacki/overview/#acki-nacki-selection-algorithm","title":"Acki-Nacki Selection Algorithm","text":"<p>The Acki-Nacki selection algorithm in the Acki Nacki blockchain involves calculating a value based on the block and the BP's secret key, then determining if it meets certain criteria to be considered Acki-Nacki. The process ensures randomness in selecting Acki-Nacki BPs, with each selection being an independent event. This method allows for control over the average number of Acki-Nacki per block.</p>"},{"location":"acki-nacki/overview/#the-new-block-production-and-broadcast","title":"The new block production and broadcast","text":"<p>In the new block production and broadcast process, a Block Producer (BP) releases a new block every 330 milliseconds by collecting unprocessed messages, executing transactions, and creating a block within certain limits. The BP signs the block with its BLS private key and broadcasts it to all Block Keepers (BKs). Upon receiving the block, a BK  computes an Attestation for the block, and sends it back to the BP.</p>"},{"location":"acki-nacki/overview/#the-block-verification","title":"The block verification","text":"<p>Block verification in the protocol is conducted by Acki-Nacki entities selected through an algorithm. These entities must validate blocks and send Ack/Nack messages to the network to avoid being slashed. Third parties can also validate blocks with a bond but are not obligated to do so. If a Block Producer (BP) creates a block with complex execution, Acki-Nacki may delay verification which may lead to  incorrect transactions being accepted. To counter this safety attack, Verifiers will stop after 330 ms and send a special Nack with a \"too complex\" message, allowing the committee to penalize the BP if necessary.</p>"},{"location":"acki-nacki/overview/#acki-nacki-selection-proof","title":"Acki-Nacki Selection Proof","text":"<p>In the Acki-Nacki selection proof process, a Block Keeper (BK) generates BLS key pairs sorted by sequential number for block verification. The BK commits the hash of each key pair to the network using a Merkle Tree. After each block, the Acki-Nacki BK reveals a private key, SeqNo, and Merkle Proof in the Verification message. Other BKs must also reveal their private keys eventually. Failure to send Verifications or provide keys accurately results in it being slashed.</p>"},{"location":"acki-nacki/overview/#proof-of-stake-and-fork-choice-rule","title":"Proof-of-Stake and Fork Choice rule","text":"<p>A Fork Choice Rule algorithm based on stake weight to resolve situations where two valid blocks exist at the same height. The algorithm determines which block to finalize by considering attestations and stake amounts. Participants are required to attest to only one block at a certain height, with penalties for attesting to multiple blocks. The protocol involves executing the Acki-Nacki Selection Algorithm for blocks with a certain number of attestations or the highest stake amount. After applying the Fork Choice Rule, the BK sends to other BKs either the block with Attestations or the block with Attestations and Ack/Nack, depending on whether they became Acki-Nacki for that block.</p>"},{"location":"acki-nacki/overview/#the-block-finalization","title":"The block finalization","text":"<p>The process of block finalization involves each BK receiving a new block, updating the state, and marking mutations as not final until receiving Attestations from BP in the Common section of subsequent blocks to meet the minimum Attestation Threshold specified in the network configuration.  The BK also waits a specified time for block to finalize after collecting the required number of block Attestations. If no negative acknowledgments (Nack) are received within the time frame, the block is marked as final. If there are insufficient block attestations, the block remains unfinalized, prompting network participants to decide on potential actions such as allowing ongoing unfinalized block production, halting the network after a set number of blocks, or considering penalties for BKs failing to provide attestations.</p>"},{"location":"acki-nacki/overview/#joint-committee","title":"Joint Committee","text":"<p>In the event of a Nack, multiple Attestations on the same block by one Block Keeper (BK), or other malicious actions, the Joint Committee function is invoked. Each BK is requested to vote for slashing malicious BKs, Block Producers (BPs), or rejecting a malicious block. The network requires as many votes, as determined by network participants, to confirm malicious activity and take appropriate actions.</p>"},{"location":"acki-nacki/overview/#slashing","title":"Slashing","text":"<p>The slashing conditions will lead network participants to either lose their stake entirely, or by some factor (bleeding). When we say \u201close\u201d we mean that the stake will be burned and not transferred to some other honest party.  There are various scenarios where slashing can occur, such as when participants fail to perform certain tasks or behave in a non-compliant manner.</p>"},{"location":"acki-nacki/overview/#dynamically-adjustable-parameters","title":"Dynamically adjustable parameters","text":"<p>One of the main advantages of the Acki Nacki consensus protocol is presence of several dynamically adjustable parameters such as the number of Attestations needed for block finalization, the average expected number of Acki-Nacki per block, the number of votes for Join Committee and the probability of a successful attack with a certain percentage of malicious BKs. All these parameters can be changed by network participants through voting according to their preferences.</p> <p>For example, one can input the number of BKs, the desired attack probability with a certain number of malicious BKs. Acki Nacki will then automatically adjust the parameters of the number of Attestations and the number of Acki-Nacki so that the network achieves the highest throughput with the shortest finality.</p>"},{"location":"acki-nacki/overview/#attacks-analysis","title":"Attacks analysis","text":"<p>In the analysis of attacks, you have the opportunity to conduct experiments with parameters using the following link.  </p> <p>Here you can create graphs illustrating the relationship between the probability of a successful attack and the number of Acki-Nacki, comparison the Acki Nacki consensus with the Nakamoto consensus and the BFT consensus, and build a graphs of the Acki-Nacki Consensus input parameters</p>"},{"location":"acki-nacki/overview/#performance-analysis","title":"Performance analysis","text":"<p>Without taking state sharding into account the limitation to performance in Acki Nacki network is down to the two factors: the number of blocks a BK can receive over the network and apply and the number of blocks all network Verifiers can process at any given moment. This performance is entirely dependent on computer and network resources committed by Participants, number of BKs and expected number of Acki-Nacki per block. </p> <p>With sharded design there is no theoretical limit to the Acki Nacki network throughput. Without sharded design, taking into account modern computer hardware and datacenter Internet connection we calculate a practical limit of 250,000 transactions per second of a minimal 500 byte messages with less than a 1 sec finality. With sharding enabled the protocol can scale to millions of transactions of any complexity just by adding computing resources which makes it comparable with centralized cloud services. </p> <p>Acki Nacki achieves this performance as a result of vastly reduced message complexity during most of its operation time.</p> <p>The Acki Nacki algorithm achieves consensus in two communication steps. The first step involves sending the block from BP to BKs. The second step involves sending of Ack/Nacks by Acki-Nacki to all BKs, in parallel with the sending of attestations from BKs to BP.</p> <p>In total the following messages are sent: The block sent from BP to BKs, the Attestations sent from BKs to BP and the Ack/Nack messages sent from several chosen Acki-Nacki to BKs. Here the positivistic scenario ends. The Nack message and accidental Forks will trigger more messages, but the Nack message is highly improbable and Forks are rare events.</p>"},{"location":"acki-nacki/connection-to-network/create-and-compile-contract/","title":"Create and compile contract","text":""},{"location":"acki-nacki/connection-to-network/create-and-compile-contract/#prerequisites","title":"Prerequisites","text":"<ul> <li>Solidity Compiler </li> </ul>"},{"location":"acki-nacki/connection-to-network/create-and-compile-contract/#install-solidity-compiler","title":"Install Solidity compiler","text":"<p>Download and install the Solidity compiler for required platform from here</p>"},{"location":"acki-nacki/connection-to-network/create-and-compile-contract/#create-contract","title":"Create contract","text":"<p>Create file <code>helloWorld.sol</code> with following content:</p> <pre><code>pragma ton-solidity &gt;= 0.35.0;\npragma AbiHeader expire;\n\n// This is class that describes you smart contract.\ncontract helloWorld {\n    // Contract can have an instance variables.\n    // In this example instance variable `timestamp` is used to store the time of `constructor` or `touch`\n    // function call\n    uint32 public timestamp;\n\n    // Contract can have a `constructor` \u2013 function that will be called when contract will be deployed to the blockchain.\n    // In this example constructor adds current time to the instance variable.\n    // All contracts need call tvm.accept(); for succeeded deploy\n    constructor() public {\n        // Check that contract's public key is set\n        require(tvm.pubkey() != 0, 101);\n        // Check that message has signature (msg.pubkey() is not zero) and\n        // message is signed with the owner's private key\n        require(msg.pubkey() == tvm.pubkey(), 102);\n        // The current smart contract agrees to buy some gas to finish the\n        // current transaction. This actions required to process external\n        // messages, which bring no value (hence no gas) with themselves.\n        tvm.accept();\n\n        timestamp = block.timestamp;\n    }\n\n    function renderHelloWorld () public pure returns (string) {\n        return 'helloWorld';\n    }\n\n    // Updates variable `timestamp` with current blockchain time.\n    function touch() external {\n        // Each function that accepts external message must check that\n        // message is correctly signed.\n        require(msg.pubkey() == tvm.pubkey(), 102);\n        // Tells to the TVM that we accept this message.\n        tvm.accept();\n        // Update timestamp\n        timestamp = block.timestamp;\n    }\n\n    function sendValue(address dest, uint128 amount, bool bounce) public view {\n        require(msg.pubkey() == tvm.pubkey(), 102);\n        tvm.accept();\n        // It allows to make a transfer with arbitrary settings\n        dest.transfer(amount, bounce, 0);\n    }\n}\n</code></pre> <p>Full TVM Solidity API reference is here</p>"},{"location":"acki-nacki/connection-to-network/create-and-compile-contract/#compiling","title":"Compiling","text":"<p>Compile the contract using Solidity compiler:</p> <pre><code>sold helloWorld.sol\n</code></pre> <p>The compiler produces <code>helloWorld.code</code>, <code>helloWorld.tvc</code> and <code>helloWorld.abi.json</code> to be used in the following steps.</p> <p>Binary code of your contract is recorded into <code>helloWorld.tvc</code> file.</p>"},{"location":"acki-nacki/connection-to-network/create-and-compile-contract/#source-code","title":"Source code","text":"<p>You can find full source code of this contract and its artifacts here</p>"},{"location":"acki-nacki/connection-to-network/create-giver/","title":"Create giver","text":""},{"location":"acki-nacki/connection-to-network/create-giver/#create-wallet-contract","title":"Create wallet-contract","text":"<p>To create your own giver, using any contract of wallet.</p> <p>For example, create file <code>giver.sol</code> with following content:</p> <pre><code>pragma ton-solidity &gt;= 0.35.0;\n\n/// @title Simple wallet\n/// @author Tonlabs\ncontract Wallet {\n    // Modifier that allows function to accept external call only if it was signed\n    // with contract owner's public key.\n    modifier checkOwnerAndAccept {\n        // Check that inbound message was signed with owner's public key.\n        // Runtime function that obtains sender's public key.\n        require(msg.pubkey() == tvm.pubkey(), 100);\n\n        // Runtime function that allows contract to process inbound messages spending\n        // its own resources (it's necessary if contract should process all inbound messages,\n        // not only those that carry value with them).\n        tvm.accept();\n        _;\n    }\n\n    /*\n     * Public functions\n     */\n\n    /// @dev Contract constructor.\n    constructor() checkOwnerAndAccept { }\n\n    /// @dev Allows to transfer grams to the destination account.\n    /// @param dest Transfer target address.\n    /// @param value Nanograms value to transfer.\n    /// @param bounce Flag that enables bounce message in case of target contract error.\n    function sendTransaction(address dest, uint128 value, bool bounce) public view checkOwnerAndAccept {\n        // Runtime function that allows to make a transfer with arbitrary settings.\n        dest.transfer(value, bounce, 3);\n    }\n\n    // Function to receive plain transfers.\n    receive() external {\n    }\n}\n</code></pre>"},{"location":"acki-nacki/connection-to-network/create-giver/#compiling","title":"Compiling","text":"<p>Compile this contract using the following instruction</p> <p>As a result, you will have 4 files:</p> <ul> <li><code>giver.sol</code> - source code of your wallet-contract;</li> <li><code>giver.code</code> - it contains the assembly code of the contract;</li> <li><code>giver.tvc</code> - binary code of your contract (the contents of this file will be deployed on network);</li> <li><code>giver.abi.json</code> - describe the interface of the contract.</li> </ul>"},{"location":"acki-nacki/connection-to-network/create-giver/#deploy","title":"Deploy","text":"<p>Let's deploy the contract to Acki Nacki development blockchain at <code>ackinacki-testnet.tvmlabs.dev</code></p> <p>1) Make sure TVM-CLI is in $PATH:</p> <pre><code>export PATH=$PATH:&lt;PATH_TO&gt;/tvm-cli\n\ntvm-cli config --url ackinacki-testnet.tvmlabs.dev\n</code></pre> <p>2) Generate address, keys and seed phrase for your giver:</p> <pre><code>tvm-cli genaddr giver.tvc --genkey giver.keys.json\n</code></pre> <p>Address of your contract in the blockchain is located after <code>Raw address:</code></p> <p></p> <p>IMPORTANT</p> <p>Save <code>Raw address</code> value - you will need it to deploy your contract and to work with it. We will refer to it as <code>&lt;YourAddress&gt;</code> below.  </p> <p>Seed phrase is also printed to stdout. Key pair will be generated and saved to the file <code>giver.keys.json</code>.</p> <p>Danger</p> <p>Write your seed phrase down and store it somewhere safe, and never share it with anyone. Avoid storing it in plain text or screenshots, or any other non-secure way. If you lose it, you lose access to your assets. Anyone who gets it, gets full access to your assets. Also, save the file with a pair of keys in a safe place.</p> <p>3) Request test tokens</p> <p>Note</p> <p>Acki Nacki deploy is fee-based, so your new contract will be charged for this. You will need to request some tokens to the address before the actual deployment. Contracts take value in nanotokens. (You will need approximately 10 tokens to deploy)</p> <p>Please contact us in Channel on Telegram and specify the <code>&lt;YourAddress&gt;</code>.</p> <p>4) Check the state of the pre-deployed contract. It should be <code>Uninit</code>:</p> <pre><code>tvm-cli account &lt;YourAddress&gt;\n</code></pre> <p>You will see something similar to the following:</p> <p></p> <p>5) Deploy your contract to the early configured network with the following command:</p> <pre><code>tvm-cli deploy --abi giver.abi.json --sign giver.keys.json giver.tvc {}\n</code></pre> <p>Info</p> <p>The arguments of the constructor must be specified in curly brackets: <code>{&lt;constructor arguments&gt;}</code></p> <p></p> <p>6) Check the contract state again. This time, it is should be <code>Active</code>.</p> <p></p>"},{"location":"acki-nacki/connection-to-network/create-giver/#request-test-tokens-for-future-use","title":"Request test tokens for future use","text":"<p>To replenish your giver, please contact us in Channel on Telegram.</p>"},{"location":"acki-nacki/connection-to-network/create-giver/#source-code","title":"Source code","text":"<p>You can find full source code of this contract and its artifacts here</p>"},{"location":"acki-nacki/connection-to-network/quick-start-tvm-cli/","title":"Quick start for TVM CLI","text":""},{"location":"acki-nacki/connection-to-network/quick-start-tvm-cli/#guide-overview","title":"Guide overview","text":"<p>This guide will help you get started with such essential Acki Nacki tools as:</p> <ul> <li>TVM-CLI </li> <li>Solidity Compiler </li> <li>Acki Nacki Blockchain Explorer </li> <li>Node GraphQL API</li> </ul> <p>You will learn how to:</p> <ul> <li>Create and compile your first Solidity contract</li> <li>Deploy your first contract</li> <li>Run it on-chain</li> <li>Run a getter-function</li> <li>Make a transfer</li> <li>Explore contract data in Explorer and GraphQL playground</li> <li>Configure your own giver</li> </ul>"},{"location":"acki-nacki/connection-to-network/quick-start-tvm-cli/#install-tvm-cli","title":"Install TVM-CLI","text":"<p>Download  and install the TVM-CLI for the platform you need from here</p>"},{"location":"acki-nacki/connection-to-network/quick-start-tvm-cli/#create-and-compile-contract","title":"Create and compile contract","text":"<p>Create and compile a contract using the following instruction.</p> <p>As a result, you will have 4 files:</p> <ul> <li><code>helloWorld.sol</code> - source code of your contract;</li> <li><code>helloWorld.code</code> - it contains the assembly code of the contract;</li> <li><code>helloWorld.tvc</code> - binary code of your contract (the contents of this file will be deployed on network);</li> <li><code>helloWorld.abi.json</code> - describe the interface of the contract.</li> </ul>"},{"location":"acki-nacki/connection-to-network/quick-start-tvm-cli/#deploy","title":"Deploy","text":"<p>Let's deploy the contract to Acki Nacki development blockchain at ackinacki-testnet.tvmlabs.dev</p> <p>1) Make sure TVM-CLI is in $PATH:</p> <pre><code>export PATH=$PATH:&lt;PATH_TO&gt;/tvm-cli\n\ntvm-cli config --url ackinacki-testnet.tvmlabs.dev\n</code></pre> <p>2) Generate address, keys and seed phrase for your contract:</p> <pre><code>tvm-cli genaddr helloWorld.tvc --genkey helloWorld.keys.json\n</code></pre> <p>Address of your contract in the blockchain is located after <code>Raw address:</code></p> <p></p> <p>IMPORTANT</p> <p>Save <code>Raw address</code> value - you will need it to deploy your contract and to work with it. We will refer to it as <code>&lt;YourAddress&gt;</code> below.  </p> <p>Seed phrase is also printed to stdout. Key pair will be generated and saved to the file <code>helloWorld.keys.json</code>.</p> <p>Danger</p> <p>Write your seed phrase down and store it somewhere safe, and never share it with anyone. Avoid storing it in plain text or screenshots, or any other non-secure way. If you lose it, you lose access to your assets. Anyone who gets it, gets full access to your assets. Also, save the file with a pair of keys in a safe place.</p> <p>3) Get some test-tokens to your account.</p> <p>Note</p> <p>You will need to send some tokens to the address before the actual deployment. Acki Nacki deploy is fee-based, so your new contract will be charged for this. (You will need about 10 tokens to deploy)</p> <p>We recommend creating a wallet-contract that will serve as your giver.</p> <p>To replenish it, please contact us in Channel on Telegram.</p> <p>4) Check the state of the pre-deployed contract. It should be <code>Uninit</code>:</p> <pre><code>tvm-cli account &lt;YourAddress&gt;\n</code></pre> <p>You will see something similar to the following:</p> <p></p> <p>5) Deploy your contract to the early configured network with the following command:</p> <pre><code>tvm-cli deploy --abi helloWorld.abi.json --sign helloWorld.keys.json helloWorld.tvc {}\n</code></pre> <p>Info</p> <p>If there are arguments in the contract constructor, then they must be specified in curly brackets <code>{&lt;constructor_arguments&gt;}</code></p> <p></p> <p>6) Check the contract state again. This time, it is should be <code>Active</code>.</p> <p></p>"},{"location":"acki-nacki/connection-to-network/quick-start-tvm-cli/#view-contract-information-with-explorer","title":"View contract information with Explorer","text":"<p>Go to Acki Nacki explorer and search for  in search bar. Open your account page. You will need it later to see its transactions and messages, that we will produce in the next steps. <p></p>"},{"location":"acki-nacki/connection-to-network/quick-start-tvm-cli/#explore-contract-information-with-graphql","title":"Explore contract information with GraphQL","text":"<p>Go to GraphQL playground. Enter in the left pane and click Run button (replace the contract's address with the one you got in the previous steps).</p> <pre><code>query {\n  accounts(\n    filter: {\n      id: {\n        eq: \"&lt;YourAddress&gt;\"\n      }\n    }\n  ) {\n    acc_type_name\n    balance\n    code\n    code_hash\n    data\n  }\n}\n</code></pre> <p>You will see something that looks similar following:</p> <p></p> <p>Info</p> <p>You can specify any other fields in the result section that are available in GraphQL Schema. Click <code>Docs</code> on the right side of your screen to explore it.</p>"},{"location":"acki-nacki/connection-to-network/quick-start-tvm-cli/#run-a-getter-function","title":"Run a getter function","text":"<p>for example, the <code>timestamp</code> method:</p> <p><pre><code>tvm-cli run &lt;YourAddress&gt; timestamp {} --abi helloWorld.abi.json\n</code></pre> result:</p> <p></p>"},{"location":"acki-nacki/connection-to-network/quick-start-tvm-cli/#call-function","title":"Call function","text":"<p>for example, the <code>touch</code> method:</p> <p><pre><code>tvm-cli call &lt;YourAddress&gt; touch {} --abi helloWorld.abi.json --sign helloWorld.keys.json\n</code></pre> result:</p> <p></p>"},{"location":"acki-nacki/connection-to-network/quick-start-tvm-cli/#transfer-of-tokens-from-own-giver","title":"Transfer of tokens from own giver","text":"<pre><code>tonos-cli call &lt;giverAddress&gt; sendTransaction '{\"dest\":\"DestAddress\", \"value\":10000000000, \"bounce\":false}' --abi giver.abi.json --sign giver.keys.json\n</code></pre> <p>Info</p> <ul> <li>Contracts take value in nanotokens</li> <li>You will need approximately 10 tokens to deploy the contract</li> <li>Bounce = true means that if the recipient does not exist, money will be returned back. If you plan to transfer money for deploy, specify Bounce = false!</li> </ul>"},{"location":"acki-nacki/connection-to-network/quick-start-tvm-cli/#whats-next","title":"What's next?","text":"<p>Congratulations, now your contract is up and running! Now, you can get acquainted with:</p> <ul> <li>Solidity API for TVM</li> <li>more contract samples</li> </ul>"},{"location":"acki-nacki/connection-to-network/quick-start-tvm-sdk/","title":"Quick start for TVM SDK","text":""},{"location":"acki-nacki/connection-to-network/quick-start-tvm-sdk/#prerequisites","title":"Prerequisites","text":"<ul> <li>Rust 1.76+</li> <li>Cargo</li> <li>Wallet-contract to be used as a giver with keys</li> <li>Contract, for example: <code>helloWorld.sol</code></li> <li>Demo application</li> </ul> <p>This demo app implements the following logic:</p> <ol> <li> <p>Creates and initialize an instance of the SDK client;</p> </li> <li> <p>Creates a giver contract instance (will be used for send tokens to helloWorld contract);</p> </li> <li> <p>Deploys the helloWorld contract:</p> <p>3.1 Generates key pair for the contract;</p> <p>3.2 Calculate future address of the contract;</p> <p>3.3 Sends to the future address of the contract some tokens required for deploy;</p> <p>3.4 Returns instance of the helloWorld contract;</p> </li> <li> <p>Calls some methods (getter and setter) of the contract.</p> </li> </ol> <p>Important</p> <p>After you have created and deployed the <code>wallet</code> and <code>helloWorld</code> contracts, you should to place their <code>ABI files</code> in the <code>resources</code> folder.</p> <p>Info</p> <p>To replenish the balance of wallet-contract, please contact us in Channel on Telegram.</p>"},{"location":"acki-nacki/connection-to-network/quick-start-tvm-sdk/#setup-giver","title":"Setup giver","text":"<p>Before you start, you should setup a wallet-contract to be used as a giver. Edit <code>.env</code> file with following content:</p> <pre><code>CONTRACT_CODE=PATH_TO_HELLOWORLD_CONTRACT_CODE    # helloWorld.tvc\nGIVER_ADDRESS=YOUR_WALLET_ADDRESS\nGIVER_KEYS=PATH_TO_YOUR_WALLET_KEYS_FILE\n</code></pre>"},{"location":"acki-nacki/connection-to-network/quick-start-tvm-sdk/#run-it","title":"Run it","text":"<pre><code>cargo run\n</code></pre> <p>You will see a result similar to the following: <pre><code>Future address: 0:41b8b9d954bfd2c9646fd3e6fc56c73cc091fd5acbcee6b1c2593b4d8beecddf\nRequesting tokens from giver-contract...\nTransaction id: 9167ef30059487d8dbfbd3e505d3fa3944218a748b9f8bc9a5344983555da377\n\nContract status: Uninit (ready to deploy)\nContract balance: 1000000000 nanotokens\nContract has been deployed\nTimestamp result[1]: 1710358282\nUpdating timestamp...\nTimestamp result[2]: 1710358284\n</code></pre></p>"},{"location":"acki-nacki/connection-to-network/quick-start-tvm-sdk/#source-code","title":"Source code","text":"<p>The source code of all the components used can be found here</p>"}]}